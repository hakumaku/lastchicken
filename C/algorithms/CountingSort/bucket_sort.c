/*
 * Pseudocode
 * BUCKET_SORT(A)
 *	n = A.length
 *	let B[0..n-1] be a new array
 *	for i = 0 to n -1
 *		make B[i]an empty list
 *	for i = 1 to n
 *		insert A[i] into list B[[n[i]]]
 *	for i = to n - 1
 *		sort list B[i] with insertion sort
 *	concatenate the lists B[0], B[1], ..., B[n-1] together in order.
 * (Note that insertion sort is just an option of many sorting algorithms.)
 *
 * Bucket sort assumes that the input is generated by a random process
 * that distributes elements 'UNIFORMLY'.
 * The less the elements are distributed uniformly the worse it performs.
 * The performance of bucket sort also depends on the number of buckets
 * you have chosen.
 * The advantage of bucket sort is you can sort much smaller arrays
 * in parallel with one another.
 */

#include <stdio.h>
#include <stdlib.h>

#define BUCKET_SIZE		4

#define TEST_VAL1	100

typedef struct {
	size_t count;
	int *arr;
} bucket_t;

void bucket_sort(int *arr, size_t len);
void print_array(int *arr, size_t len);

int main(void)
{
	int test1[TEST_VAL1] = { 0 };
	for(int i = 0; i < TEST_VAL1; i++)
		test1[i] = TEST_VAL1 - i;

	bucket_sort(test1, TEST_VAL1);
	print_array(test1, TEST_VAL1);

	return 0;
}

void bucket_sort(int *arr, size_t len)
{
	int arr_val = 0, arr_pos = 0;
	bucket_t bucket[BUCKET_SIZE];
	for(size_t i = 0; i < BUCKET_SIZE; i++)
	{
		bucket[i].count = 0;
		/*	This should be a linked list.	*/
		bucket[i].arr = (int *)calloc(len, sizeof(int));
	}


	for(size_t i = 0; i < len; i++)
	{
		arr_val = arr[i];
		if(arr_val < 0)
			arr_pos = 0;
		else if(arr_val < 30)
			arr_pos = 1;
		else if(arr_val < 60)
			arr_pos = 2;
		else
			arr_pos = 3;

		bucket[arr_pos].arr[bucket[arr_pos].count++] = arr_val;
	}

	for(size_t i = 0; i < BUCKET_SIZE; i++)
	{
		/*	Insertion sort	*/
		int *list = bucket[i].arr;
		size_t boundary = bucket[i].count;
		int smaller = 0;
		for(size_t j = 1, k = 0; j < boundary; j++)
		{
			smaller = list[j];
			for(k = j-1; k != (size_t)-1 && smaller < list[k]; k--)
				list[k+1] = list[k];
			list[k+1] = smaller;
		}
		/*	Writing back	*/
		for(size_t j = 0; j < boundary; j++)
		{
			*arr = list[j];
			arr++;
		}
		/*	Freeing previous allocation here.	*/
		free(list);
	}
}
void print_array(int *arr, size_t len)
{
	for(size_t i = 0; i < len; i++)
		printf("%d ", arr[i]);
	putchar('\n');
}
